package com.aads.combinatorics.partitions.splittingNumberIntoMParts;

import java.util.Arrays;

/**
 *                  Разбиение числа на m частей
 *
 *                  Сведение о алгоритме
 *          Сложность по времени в наихудшем случае O(m)
 *          Сложность указанна для одного разбиения!
 *
 *                  Разбиение числа на m частей
 *           Разбиение целого числа n на m частей — представление числа n в виде кортежа
 *      длинной m сумма элементов которого равна n. При этом должно выполняться условие,
 *      что n≥m≥2.
 *          Например разбиение числа 8 на 4 части можно представить как
 *              1)8 = 5+1+1+1
 *              2)8 = 4+2+1+1
 *              3)8 = 3+3+1+1
 *              4)8 = 3+2+2+1
 *              5)8 = 2+2+2+2
 *
 *                  Сведения о авторе алгоритма
 *          Данный алгоритм был предложен в 1779 году К.Ф. Гиденбургом (C.F. Hindenburg).
 *      Карл Фридрих Гинденбург (1741-1808) - немецкий математик, физик, философ,
 *      профессор, педагог, ректор Лейпцигского университета. Член Прусской академии наук
 *      (1806).
 *          Основные направления научной деятельности — комбинаторика и теория
 *      вероятности. Известен работами по умножению и возведению рядов в рациональную
 *      степень, а также по алгебре. В 1778 году издавал серию работ по комбинаторике, в
 *      частности, теории вероятности, формул для высших дифференциалов. Работал над
 *      обобщением бинома Ньютона. Оказал большое влияние на работы Кристофа Гудермана
 *      в области аналитического продолжения степенного ряда, ставшего со временем
 *      фундаментом его теории аналитических функций. Был основателем и руководителем
 *      комбинаторной школы в математике, издавал «Собрания комбинаторно-аналитических
 *      статей».
 *
 *                  Описание алгоритма
 *          1) Создаем последовательность a длинной m. Устанавливаем a0=n-m+1, остальные элементы
 *      равные 1. Переходим к 2.
 *          2) Возвращаем последовательность в качестве разбиения. Выполнить проверку a1<a0-1, если это
 *      условие истинно перейти к 3, в противном случае перейти к 4.
 *          3) Установить a0=a0-1, a1=a1+1. Перейти к 2.
 *          4) Начиная с второго элемента последовательности ищем элемент удовлетворяющий условию aj<a0 -1.
 *      Если такого элемента не найдено заканчиваем алгоритм. Вычисляем сумму всех
 *      элементов до найденного элемента минус 1(обозначим как s). Увеличим значение найденного
 *      элемента на единицу. Переходим к 5.
 *          5) Выполняем проход от второго элемента до найденного элемента последовательности. На
 *      каждом шаге устанавливаем значение равное значению найденного элемента, при этом
 *      уменьшая значение s на эту величину. После завершения прохода устанавливаем значение
 *      первого элемента последовательности как s. Перейти к 2.
 */

public class SplittingNumberIntoMParts {

    public static void main(String[] args) {

        printNumberPartition(8, 4);

    }

    public static void printNumberPartition(int n, int m) {
        int[] part = new int[m];
        Arrays.fill(part, 1);
        part[0] = n - m + 1;
        while (true) {
            System.out.println(Arrays.toString(part));
            if (part[1] < part[0] - 1) {
                part[0] -= 1;
                part[1] += 1;
            } else {
                int j = -1;
                int s = part[0] - 1;
                for (int i = 1; i < part.length; i++) {
                    if (part[i] < part[0] - 1) {
                        j = i;

                        break;
                    }
                    s += part[i];
                }
                if (j == -1) {
                    break;
                }
                part[j] += 1;
                for (int i = 1; i < j; i++) {
                    part[i] = part[j];
                    s -= part[j];
                }
                part[0] = s;
            }
        }
    }
}
